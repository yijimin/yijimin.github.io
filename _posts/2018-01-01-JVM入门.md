## JVM体系结构

灰色区域：线程独有，不会被GC回收

橙色区域：线程共享，会被GC管理或回收	

* 程序计数器 The pc Register

JVM支持多线程同时执行，每一个线程都有自己的pc register，线程正在执行的方法叫做当前方法。如果是java代
码，pc register中存放的就是当前正在执行的指令的地址，如果是c代码，则为空。

* Java虚拟机栈 Java Virtual Machine Stacks

Java虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

**8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配**。

* 堆 Heap

Java堆是Java虚拟机所管理的内存中最大的一块。对是被所有线程共享的一块内存区域，在虚拟机启动时创建。次
内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可（因此逻辑上分为**新生+养老+方法区**）。

* 方法区 Method Area

方法区和Java堆一样，是各个线程共享的内存区域，也是在虚拟机启动时创建。它用于存储已被虚拟机加载的类信
息（类的版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，
但是它却有一个别名叫做Non-Heap(非堆)，目的是与Java堆区分开来。

jdk1.8中就是metaspace （元空间）

jdk1.6或者1.7中就是perm space (永久区)，永久代是方法区的实现

Jdk1.6 及之前： 有永久代 , 常量池 1.6 在方法区 
Jdk1.7 ： 有永久代，但已经逐步“去”，常量池 1.7 在堆 
Jdk1.8 及之后： 无永久代，常量池 1.8

运行时常量池Runtime Constant Pool是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述·信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

* 本地方法栈 Native Method Stacks

本地方法栈和虚拟机栈锁发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈执行Java方法服务，而本地方
法栈则为虚拟机使用到的native方法服务。

## 内存模型-JMM（内存结构）

内存结构的设计一块是非堆区，一块是堆区。

堆区分为两大块，一个是Old区，一个是Young区。
Young区分为两大块，一个是Survival区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1
S0和S1一样大，也可以叫From和To。
在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。

## ClassLoader

类装载器：负责加载class文件

分为：启动类装载器、扩展类装载器、系统类装载器、自定义类装载器 

## 双亲委派机制

委派给父加载器（上一级）去加载，如果父加载器加载不到在交给子加载器去加载。在ClassLoader.java 401行说明了双亲委派机制。

安全，防止使用者篡改JDK代码 

例如：新建一个String，写上main方法，运行时会提示找不到main方法。因为是String类在rt.jar中，由启动类加载器Bootstrap来加载。

## Native

一些java以外的代码（C、C++）

## 命令

* jps   

  查看java进程状态 	，类似与 linux 的 ps 命令，但是它只列出系统中所有的 Java 应用程序（不带参数，默认显示 进程ID 和 启动类的名称）

  jps -l	显示详细信息


* jstat

  jstat命令可以查看堆内存各部分的使用量，以及加载类的数量

  jstat -gcutil  <pid> <lines>    显示垃圾收集信息

* jinfo

  jinfo -flags PID 查看曾经赋过值的一些参数

* jmap

  打印出堆信息，可以获得运行中的jvm的堆的快照，从而可以离线分析堆，以检查内存泄漏，检查一些严重影响性能的大对象的创建，检查系统中什么对象最多，各种对象所占内存的大小等等。可以使用jmap生成Heap Dump

* jconsole

* jhat

* jstack

  主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）

* javap -verbose xxx.class  解析类文件（对javac编译的文件进行反编译）

## 分析工具

dump文件分析工具 - MAT



## 对象创建

方式：new、clone（克隆）、反射、序列化

### 内存的分配方法

指针碰撞

空闲列表

## 垃圾回收

### 如果判定对象是否需要回收

引用计数法：添加一个计数器，当有地方引用这个对象的时候，计数器加1，失效的时候减1，计数器为0时，无引用，进行回收

可达性分析：通过可达性分析（Reachability Analysis）来判定对象是否存活的。该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。

能作为根节点（GC Roots）的:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等

### 常量的垃圾回收算法

* 标记清除

  先标记所有需要回收的对象，然后统一回收

  缺点:效率不高，标记和清除两个过程的效率都不高，容易产生碎片，碎片太多会导致提前GC

* 复制

  将内存按容量划分为大小相等的两块(S0和S1)，每次只使用其中一块。
  当这块使用完了，就讲还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次性清除掉【Young区此采用的是复制算法】
  优缺点:实现简单，运行高效，但是空间利用率低。

* 标记整理

标记需要回收的对象，然后让所有存活的对象移动到另外一端，直接清理掉端边界以外的内存。

#### JVM中采用的是分代垃圾回收

换句话说，堆中的Old区和Young区采用的垃圾回收算法是不一样的。
（1）Young区：复制算法
（2）Old区：标记清除或标记整理
对象在被分配之后，可能声明周期比较短，Young区复制效率比较高。
Old区对象存活时间比较长，复制来复制去没必要，不如做个标记。

### 内存分配策略

* 对象优先分配在Eden区
* 大对象直接进入老年代，多大的对象称为大对象？可以通过JVM参数指定 -XX:PretenureSizeThreshold
* 长期存活对象进入老年代
* 空间担保

等等

### 垃圾收集器

并行：一起执行

并发：一起发生

* 串行收集器Serial:Serial、Serial Old（单线程）

一个线程跑，停止，启动垃圾回收线程，回收完成，继续执行刚才暂停的线程。适用于内存比较小的嵌入式
设备中。

Serial（单线程）收集器:新生代收集器,复制算法

Serial Old(单线程GC)收集器：老年代版本，使用“标记-整理”算法

* 并行收集器Parallel:Parallel Scavenge、Parallel Old，吞吐量优先

多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态，适合科学计算、后台处理等弱交互场景

ParNew（多线程）收集器：Service模式下虚拟机中首选的新生代收集器，使用复制算法

Parallel Scavenge(多线程回收GC)收集器

* 并发收集器Concurrent:CMS（Concurrent Mark Sweep）、G1（分代收集器，可以并发与并行），停顿时间优先

用户线程和垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾收集线程在执行的时候不会停
顿用户程序的运行。适合于对相应时间有要求的场景，比如Web。 

CMS：采用标记清除算法

G1：采用标记压缩算法，（jdk1.7开始， jdk1.8非常成熟，jdk1.9默认的垃圾收集器）

ZGC：（jdk11开始）

### 垃圾回收机制

GC触发条件：Eden区满了触发Minor GC（也叫YoungGC），这时会把Eden区存活的对象复制到Survivor区，当对象在Survivor区熬过一定次数的Minor GC之后，就会晋升到老年代（当然并不是所有的对象都是这样晋升的到老年代的），当老年代满了，就会报OutofMemory异常。

#### Minor GC

新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。

在执行机制上JVM提供了串行GC(SerialGC)、并行回收GC(ParallelScavenge)和并行GC(ParNew)：

#### 老年代的GC（Major GC/Full GC）

老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗。

在执行机制上JVM提供了串行GC(Serial MSC)、并行GC(Parallel MSC)和并发GC(CMS)。

## Class文件简介

文件结构

## 类加载过程

![1551614610079](../../../AppData/Local/Temp/1551614610079.png)